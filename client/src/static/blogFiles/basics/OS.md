# Operating System

## 1. 内存泄漏与内存溢出

### 1.1. 内存泄漏 Memory Leak

内存泄漏是指程序在分配了内存后未能释放，且该内存再也不会被使用。这意味着随着时间的推移，不断累积的未释放内存可能导致程序消耗的总内存持续增长，最终可能导致系统资源枯竭。 

**原因**：

- 对象被创建但未被销毁。
- 注册的事件监听器没有被移除。
- 闭包导致的未预期的引用。

**如何发现**：

- 使用专门的工具或分析器来检测和定位泄漏，例如在浏览器中，可以使用Chrome开发者工具的Memory选项卡。
- 监控应用程序的内存使用情况，如果持续增长，可能有泄漏。

### 1.2. 内存溢出 Memory Overflow

内存溢出指的是当程序尝试使用比系统分配给它的更多内存时发生的情况。通常，这会导致程序崩溃或异常终止。

**原因**：

- 尝试分配超出可用内存的大型数据结构。
- 递归调用无法终止，导致调用栈溢出。
- 超出数组或数据结构的边界。

**如何发现**：

- 大多数编程环境和操作系统都会在出现内存溢出时产生错误或异常，如JavaScript会抛出“RangeError: Maximum call stack size exceeded”（这是由于调用栈溢出）。

## 2. 进程调度

### 2.1. 调度方法

1. **先来先服务 (FCFS, First-Come-First-Serve)**：按照进程到达的顺序进行调度。它是最简单的调度算法，但可能导致“饥饿”问题。
2. **短作业优先 (SJF, Shortest Job First)**：优先调度预计运行时间最短的进程。这种方法可以最小化平均等待时间，但实际上很难知道进程的运行时间。
3. **优先级调度**：每个进程都有一个优先级，系统优先调度优先级最高的进程。这种方法可能导致低优先级的进程饿死。
4. **时间片轮转 (RR, Round Robin)**：每个进程被分配一个固定大小的时间片或量子。当一个进程的时间片用完时，它被放回就绪队列的末尾，然后调度下一个进程。
5. **多级反馈队列 (MFQ, Multilevel Feedback Queue)**：结合了基于优先级和基于时间片的调度。进程可以在不同的队列之间移动，这取决于它们的行为和估计的CPU时间。
   1. **初始化**：新进程首先被放入最高优先级的队列。
   2. **执行**：当CPU可用时，它首先从最高优先级的队列中选择进程。如果该队列为空，它将转到下一个优先级的队列，依此类推。
   3. 调整优先级：
      - 如果进程在其当前队列的时间片内完成，则退出系统。 
      - 如果进程在其时间片内没有完成（即用完了其时间片），则它被移到下一个优先级较低的队列。
      - 如果进程等待I/O操作并在其时间片内完成该I/O操作，则它可能被移到优先级较高的队列，因为这表明它是一个I/O密集型进程，而不是CPU密集型进程。
   4. **时间片大小**：通常，队列的优先级越低，其时间片就越大。这意味着在高优先级队列中，进程获得的时间片较短，而在低优先级队列中，进程获得的时间片较长。

### 2.2. 名词定义

 加权等待时间=$$\frac{等待时间}{服务时间}$$

响应比=$$\frac{等待时间+服务时间}{服务时间}$$

## 3. 垃圾回收

- **引用计数**：这是最早的垃圾回收机制之一。对象有一个引用计数属性，每当引用它的数量增加或减少时，此计数都会相应地增加或减少。当引用计数为0时，对象被视为不再可用，可以被回收。

- **标记-清除**：这是现代垃圾回收算法的基础。在这种方法中，垃圾回收器会定期“标记”所有从根开始的活动对象，然后“清除”所有未被标记的对象。

- **分代收集**（Generational Garbage Collection）是一种优化垃圾回收的策略。其基本思想是基于一个观察：许多对象很快就会变得不可达（即它们很快就会死亡），而一些对象一旦存活了一段时间，就可能会存活很长时间。

  基于这个观察，分代收集将对象分为两个或多个“代”或“世代”，通常至少有两代：新生代和老生代。

  1. **新生代（Young Generation）**：新创建的对象首先被分配到新生代。这部分的内存相对较小，且经常被完全回收。
  2. **老生代（Old Generation）**：长时间存活的对象最终会从新生代晋升到老生代。老生代的内存区域通常比新生代大，且回收频率较低。

  **工作流程**：

  1. 当新生代的内存被填满时，垃圾回收器会运行，并清除那些不再被引用的对象。
  2. 那些在新生代中存活足够长时间的对象会被移动到老生代。
  3. 老生代的回收不是很频繁，但每次回收都会更加彻底。

## 4. Linux操作

1. **查找命令**

**`find` 命令**: `find` 是一个非常强大的命令，用于在目录树中搜索文件。基本语法是 `find [path] [expression]`。

- 寻找名为 "myfile.txt" 的文件在当前目录及其子目录中：

  ```bash
  find . -name myfile.txt
  ```

- 寻找所有 `.txt` 文件在 `/home/user` 目录及其子目录中：

  ```bash
  find /home/user -name "*.txt"
  ```

- 寻找在 `/var/log` 目录中的文件，它们在 7 天内被修改过：

  ```bash
  find /var/log -mtime -7
  ```

2. **查找进程**

ps：

1. - 查看与当前终端关联的进程(**仅返回与当前terminal有关的进程**)：

     ```bash
     ps
     ```

   - 查看所有进程的详细信息：

     ```bash
     ps aux
     ```

2. 根据进程名（通常是command名）查询进程：

```bash
ps aux | grep "node index.js"
```

这里的 `ps aux` 命令列出了所有正在运行的进程，而 `grep "node index.js"` 则过滤出与 `node index.js` 相关的进程。

输出的每一行都会包含与 `node index.js` 匹配的进程的详细信息，其中第二列是PID。

请注意，`grep` 命令本身也会出现在结果中，因为它的命令行包含了搜索的模式 "node index.js"。为了排除这个结果，你可以使用一个小技巧：

```bash
ps aux | grep "node index.js" | grep -v grep
```

这里的 `grep -v grep` 命令会排除包含 "grep" 的行，从而只显示与 `node index.js` 相关的进程。

3. 根据进程号PID查询进程：

```bash
ps aux | grep "336909" | grep -v grep
```

3. **查找日志最新十条**

在Linux中，可以使用`tail`命令来查看文件的最后几行，这在查看日志文件时特别有用。如果你想查看日志的最新10条记录，可以使用以下命令：

```bash
tail -n 10 /path/to/logfile.log
```

其中，`/path/to/logfile.log`是日志文件的路径。

例如，如果你想查看系统的消息日志（`/var/log/messages`）的最新10条记录（请注意，不是所有的Linux发行版都有这个日志文件，它可能在其他位置或有不同的名称，如`/var/log/syslog`），你可以使用：

```bash
tail -n 10 /var/log/messages
```

如果你想实时查看新添加到日志文件的内容，可以使用`tail`命令的`-f`选项：

```bash
tail -f -n 10 /path/to/logfile.log
```

这将显示日志文件的最后10行，并在新的日志条目被添加时实时显示它们。

4. **更改文件权限/所属组**

   `chmod` (Change Mode)


`chmod` 用于更改文件或目录的权限。

文件/目录权限分为三种类型：

- **u** (user): 文件的所有者。
- **g** (group): 文件的所属组。
- **o** (others): 其他用户。

每种权限可以是以下之一：

- **r** (read): 读取权限。
- **w** (write): 写入权限。
- **x** (execute): 执行权限。

使用方法：

1. **符号模式**:

   ```bash
   chmod u+x filename   # 给文件所有者添加执行权限
   chmod g-w filename   # 从文件的所属组中删除写入权限
   chmod o=r filename   # 设置其他用户的权限为只读
   chmod u=rw,g=r,o=r filename   # 设置多个权限
   ```

2. **八进制模式**:

   - r = 4
   - w = 2
   - x = 1

   ```bash
   chmod 755 filename   # rwxr-xr-x: 所有者有读/写/执行权限，组和其他用户只有读/执行权限
   ```

   

   ## `chown` (Change Owner)

`chown` 用于更改文件或目录的所有者和/或所属组。

使用方法：

1. **更改所有者**:

   ```bash
   chown newowner filename
   ```

2. **更改所有者和组**:

   ```bash
   chown newowner:newgroup filename
   ```

3. **只更改组**:

   ```bash
   chown :newgroup filename
   ```

4. **递归更改目录及其内容的所有者/组**:

   ```bash
   chown -R newowner:newgroup directoryname
   ```

注意：通常，你需要超级用户 (root) 权限才能使用 `chown` 更改文件或目录的所有者。

总的来说，`chmod` 和 `chown` 是文件和目录权限管理的基础工具，对于系统管理员和开发者来说，熟悉它们是非常重要的。

5. **网络相关指令**

`ifconfig`:

**主要关注**: 网络接口

**主要功能**:

- 查看和配置网络接口的属性，如 IP 地址、子网掩码和MAC地址。
- 查看接口的统计信息，如发送和接收的数据包数量。

**示例场景**:

- 你想知道你的计算机的 IP 地址。
- 你想更改某个网络接口的 IP 地址。

`netstat`:

**主要关注**: 网络连接和路由

**主要功能**:

- 查看当前的网络连接（哪些端口正在被使用，哪些远程地址正在连接到你的机器）。
- 查看路由表（数据应该如何从你的机器路由到其他位置）。
- 查看每个接口的网络统计信息。

**示例场景**:

- 你想知道哪些服务正在监听哪些端口。
- 你想知道你的机器与哪些远程地址有活动的连接。
- 你想查看你的机器的路由表。

简单对比:

想象一下，你的计算机是一个大楼。

- 使用 `ifconfig` 就像检查大楼的入口和出口（即门）——你可以看到每扇门的大小、类型、是否打开等。
- 使用 `netstat` 就像查看大楼内的人流和出入记录——你可以看到哪些人进来、哪些人出去、他们从哪里来、他们去哪里等。



## 5. 进程与线程

### 1. 对比

进程（Process）：

1. **定义**：进程是一个程序在一个数据集上的一个执行实例。它是系统资源分配的基本单位，也是操作系统结构的基础。
2. **资源分配**：每个进程都有自己的独立的地址空间、代码、数据和系统资源。
3. **隔离性**：进程之间是相互隔离的，一个进程的操作不会影响到其他进程。
4. **开销**：进程的创建、维护和切换都有相对较大的开销。
5. **通信**：进程间的通信（IPC）通常比较复杂，常用的方法有管道、消息队列、共享内存等。

线程（Thread）：

1. **定义**：线程是进程中的一个单一的顺序控制流，是CPU调度和分派的基本单位。
2. **资源共享**：同一进程中的所有线程共享相同的地址空间、代码和数据。但每个线程都有自己的运行栈和程序计数器。
3. **隔离性**：由于线程共享相同的地址空间，所以一个线程的操作可能会影响到其他线程。
4. **开销**：与进程相比，线程的创建、维护和切换的开销都较小。
5. **通信**：线程间的通信比进程间的通信要简单得多，因为它们共享相同的地址空间。

### 2. 线程状态

#### 2.1. 一般状态 7类

1. **新建（New）**:
   - 当我们创建了一个线程对象但还没有调用它的`start()`方法时，线程处于新建状态。
   - 在这个状态下，线程还没有开始执行。
2. **就绪（Runnable）**:
   - 当线程对象被创建并调用了`start()`方法后，线程就进入了就绪状态。
   - 在这个状态下，线程已经获取了执行所需的所有资源，只是在等待CPU的调度。
3. **运行（Running）**:
   - 当线程获得CPU时间并开始执行其任务时，它处于运行状态。
   - 在这个状态下，线程正在执行其指定的任务。
4. **阻塞（Blocked）**:
   - 当线程正在等待某个外部事件发生（如I/O操作完成）或等待某个资源可用时，它处于阻塞状态。
   - 线程在此状态下不会执行任何任务。
5. **等待（Waiting）**:
   - 当线程等待另一个线程执行特定的操作（例如，等待另一个线程发送信号或完成某个任务）时，它处于等待状态。
   - 线程在此状态下不会执行任何任务，并且无限期地等待，直到某个外部事件使其退出此状态。
6. **超时等待（Timed Waiting）**:
   - 这与等待状态类似，但有一个重要的区别：线程在这个状态下只会等待指定的时间。
   - 如果在指定的时间内没有外部事件发生，线程将自动返回到就绪状态。
7. **终止（Terminated）**:
   - 当线程完成其任务或因某种原因被终止时，它处于终止状态。
   - 在这个状态下，线程已经完成了其生命周期，不能再次启动。

#### 2.2. java状态 6类

1. **NEW (新建)**:
   - 当线程被创建但`start()`方法还未被调用时，线程处于NEW状态。
   - 在这个状态下，线程还没有开始执行。
2. **RUNNABLE (可运行)**:
   - 当线程正在Java虚拟机中执行，但可能在操作系统的视角下等待其他资源时，它处于RUNNABLE状态。
   - 这个状态是Java中的就绪和运行两个状态的结合。
3. **BLOCKED (阻塞)**:
   - 当线程正在等待一个监视器锁（通常是因为它试图进入一个`synchronized`块）时，它处于BLOCKED状态。
   - 线程在此状态下不会执行任何任务，直到获取到锁。
4. **WAITING (等待)**:
   - 当线程正在无限期地等待另一个线程执行特定的操作时（例如，本线程调用`Object.wait()`方法），它处于WAITING状态。
   - 线程在此状态下不会执行任何任务，直到接收到通知（例如，其他线程调用`Object.notify()`方法）。
5. **TIMED_WAITING (超时等待)**:
   - 当线程等待另一个线程执行操作，但有一个指定的等待时间时（例如，调用`Thread.sleep(long millis)`或`Object.wait(long timeout)`），它处于TIMED_WAITING状态。
   - 如果在指定的时间内没有外部事件发生，线程将自动返回到RUNNABLE状态。
6. **TERMINATED (终止)**:
   - 当线程完成其任务或因某种原因被终止时，它处于TERMINATED状态。
   - 在这个状态下，线程已经完成了其生命周期，不能再次启动。









