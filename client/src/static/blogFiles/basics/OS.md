# Operating System

## 1. 内存泄漏与内存溢出

### 1.1. 内存泄漏 Memory Leak

内存泄漏是指程序在分配了内存后未能释放，且该内存再也不会被使用。这意味着随着时间的推移，不断累积的未释放内存可能导致程序消耗的总内存持续增长，最终可能导致系统资源枯竭。 

**原因**：

- 对象被创建但未被销毁。
- 注册的事件监听器没有被移除。
- 闭包导致的未预期的引用。

**如何发现**：

- 使用专门的工具或分析器来检测和定位泄漏，例如在浏览器中，可以使用Chrome开发者工具的Memory选项卡。
- 监控应用程序的内存使用情况，如果持续增长，可能有泄漏。

### 1.2. 内存溢出 Memory Overflow

内存溢出指的是当程序尝试使用比系统分配给它的更多内存时发生的情况。通常，这会导致程序崩溃或异常终止。

**原因**：

- 尝试分配超出可用内存的大型数据结构。
- 递归调用无法终止，导致调用栈溢出。
- 超出数组或数据结构的边界。

**如何发现**：

- 大多数编程环境和操作系统都会在出现内存溢出时产生错误或异常，如JavaScript会抛出“RangeError: Maximum call stack size exceeded”（这是由于调用栈溢出）。

## 2. 进程调度

### 2.1. 调度方法

1. **先来先服务 (FCFS, First-Come-First-Serve)**：按照进程到达的顺序进行调度。它是最简单的调度算法，但可能导致“饥饿”问题。
2. **短作业优先 (SJF, Shortest Job First)**：优先调度预计运行时间最短的进程。这种方法可以最小化平均等待时间，但实际上很难知道进程的运行时间。
3. **优先级调度**：每个进程都有一个优先级，系统优先调度优先级最高的进程。这种方法可能导致低优先级的进程饿死。
4. **时间片轮转 (RR, Round Robin)**：每个进程被分配一个固定大小的时间片或量子。当一个进程的时间片用完时，它被放回就绪队列的末尾，然后调度下一个进程。
5. **多级反馈队列 (MFQ, Multilevel Feedback Queue)**：结合了基于优先级和基于时间片的调度。进程可以在不同的队列之间移动，这取决于它们的行为和估计的CPU时间。
   1. **初始化**：新进程首先被放入最高优先级的队列。
   2. **执行**：当CPU可用时，它首先从最高优先级的队列中选择进程。如果该队列为空，它将转到下一个优先级的队列，依此类推。
   3. 调整优先级：
      - 如果进程在其时间片内完成，则它继续保持在当前队列。
      - 如果进程在其时间片内没有完成（即用完了其时间片），则它被移到下一个优先级较低的队列。
      - 如果进程等待I/O操作并在其时间片内完成，则它可能被移到优先级较高的队列，因为这表明它是一个I/O密集型进程，而不是CPU密集型进程。
   4. **时间片大小**：通常，队列的优先级越低，其时间片就越大。这意味着在高优先级队列中，进程获得的时间片较短，而在低优先级队列中，进程获得的时间片较长。

### 2.2. 名词定义

 加权等待时间=$$\frac{等待时间}{服务时间}$$

响应比=$$\frac{等待时间+服务时间}{服务时间}$$

## 3. 垃圾回收

- **引用计数**：这是最早的垃圾回收机制之一。对象有一个引用计数属性，每当引用它的数量增加或减少时，此计数都会相应地增加或减少。当引用计数为0时，对象被视为不再可用，可以被回收。

- **标记-清除**：这是现代垃圾回收算法的基础。在这种方法中，垃圾回收器会定期“标记”所有从根开始的活动对象，然后“清除”所有未被标记的对象。

- **分代收集**（Generational Garbage Collection）是一种优化垃圾回收的策略。其基本思想是基于一个观察：许多对象很快就会变得不可达（即它们很快就会死亡），而一些对象一旦存活了一段时间，就可能会存活很长时间。

  基于这个观察，分代收集将对象分为两个或多个“代”或“世代”，通常至少有两代：新生代和老生代。

  1. **新生代（Young Generation）**：新创建的对象首先被分配到新生代。这部分的内存相对较小，且经常被完全回收。
  2. **老生代（Old Generation）**：长时间存活的对象最终会从新生代晋升到老生代。老生代的内存区域通常比新生代大，且回收频率较低。

  **工作流程**：

  1. 当新生代的内存被填满时，垃圾回收器会运行，并清除那些不再被引用的对象。
  2. 那些在新生代中存活足够长时间的对象会被移动到老生代。
  3. 老生代的回收不是很频繁，但每次回收都会更加彻底。

## 4. Linux操作

1. **`find` 命令**: `find` 是一个非常强大的命令，用于在目录树中搜索文件。基本语法是 `find [path] [expression]`。

- 寻找名为 "myfile.txt" 的文件在当前目录及其子目录中：

  ```bash
  find . -name myfile.txt
  ```

- 寻找所有 `.txt` 文件在 `/home/user` 目录及其子目录中：

  ```bash
  find /home/user -name "*.txt"
  ```

- 寻找在 `/var/log` 目录中的文件，它们在 7 天内被修改过：

  ```bash
  find /var/log -mtime -7
  ```















