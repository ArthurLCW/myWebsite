# Database

## 1. MySQL基本操作

数据库操作基本的语句包括：

1. 创建数据库：

   ```mysql
   CREATE DATABASE database_name;
   ```

2. 删除数据库：

   ```mysql
   DROP DATABASE database_name;
   ```

3. 创建表：

   ```mysql
   CREATE TABLE table_name (
       column1 datatype,
       column2 datatype,
       ...
   );
   ```

4. 删除表：

   ```mysql
   DROP TABLE table_name;
   ```

5. 插入数据：

   ```mysql
   INSERT INTO table_name (column1, column2, ...) 
   VALUES (value1, value2, ...);
   ```

6. 更新数据：

   ```mysql
   UPDATE table_name 
   SET column1 = value1, column2 = value2, ...
   WHERE condition;
   ```

7. 删除数据：

   ```mysql
   DELETE FROM table_name 
   WHERE condition;
   ```

8. 查询数据：

   ```mysql
   SELECT column1, column2, ... 
   FROM table_name 
   WHERE condition;
   ```

9. 排序数据：

   ```mysql
   SELECT column1, column2, ... 
   FROM table_name 
   ORDER BY column1 ASC/DESC;
   ```

10. 连接表：

    ```mysql
    SELECT column1, column2, ...
    FROM table1 
    INNER JOIN table2 
    ON table1.column = table2.column;
    ```

在MySQL中，内连接（Inner Join）和外连接（Outer Join）是用于联接（Join）多个表的操作。

内连接是通过匹配两个表之间的共同值，返回满足连接条件的行。只有在两个表中都存在匹配的行时，才会返回结果。内连接可以使用关键字`JOIN`或`INNER JOIN`来表示。

外连接是根据连接条件返回满足条件的行，并且包括未匹配的行。外连接分为左外连接（Left Outer Join）、右外连接（Right Outer Join）和全外连接（Full Outer Join）。

- 左外连接返回左表中所有的行，以及右表中与左表匹配的行。如果右表中没有匹配的行，则返回NULL值。
- 右外连接返回右表中所有的行，以及左表中与右表匹配的行。如果左表中没有匹配的行，则返回NULL值。
- 全外连接返回左表和右表中所有的行，如果没有匹配的行，则返回NULL值。

11. 聚合表

`GROUP BY` 是 SQL 中的一个非常重要的子句，它允许你根据一个或多个列的值将查询结果分组。这通常与聚合函数（如 `SUM`, `COUNT`, `AVG`, `MAX`, `MIN` 等）结合使用，以对每个分组进行某种计算。

**基本用法**

假设我们有一个名为 `Sales` 的表：

```mysql
| Date       | Product | Amount |
|------------|---------|--------|
| 2023-01-01 | A       | 10     |
| 2023-01-01 | B       | 15     |
| 2023-01-02 | A       | 20     |
| 2023-01-02 | A       | 10     |
| 2023-01-03 | B       | 5      |
```

**按单一列分组**：

如果我们想知道每种产品的总销售额，我们可以这样写：

```mysql
SELECT Product, SUM(Amount) as TotalSales
FROM Sales
GROUP BY Product;
```

结果可能是：

```mysql
| Product | TotalSales |
|---------|------------|
| A       | 40         |
| B       | 20         |
```

**按多列分组**：

如果我们想知道每天每种产品的销售额，我们可以这样写：

```mysql
SELECT Date, Product, SUM(Amount) as TotalSales
FROM Sales
GROUP BY Date, Product;
```

结果可能是：

```mysql
| Date       | Product | TotalSales |
|------------|---------|------------|
| 2023-01-01 | A       | 10         |
| 2023-01-01 | B       | 15         |
| 2023-01-02 | A       | 30         |
| 2023-01-03 | B       | 5          |
```

**注意事项**

1. **选择列**：在使用 `GROUP BY` 子句时，**`SELECT` 语句中的每个列要么是聚合的，要么是包含在 `GROUP BY` 子句中的**。你不能选择一个既不在 `GROUP BY` 中，也没有被聚合的列。

2. **排序**：默认情况下，`GROUP BY` 会按照分组列的顺序对结果进行排序。但你可以使用 `ORDER BY` 子句来自定义排序。

3. **HAVING**：与 `WHERE` 子句类似，`HAVING` 子句允许你过滤分组的结果。区别在于 `WHERE` 过滤行，而 `HAVING` 过滤组。

   例如，如果我们只想看销售额超过 25 的产品：

   ```mysql
   SELECT Product, SUM(Amount) as TotalSales
   FROM Sales
   GROUP BY Product
   HAVING TotalSales > 25;
   ```

## 2. 索引

在MySQL中，索引是一种用于提高查询效率的数据结构。它类似于书籍的目录，可以帮助数据库系统快速定位和访问数据。

索引的优点包括：

- 提高查询速度：索引可以加快数据库的查询速度，通过使用索引，数据库可以快速定位到满足查询条件的数据，而不需要逐行扫描整个表。
- 减少IO操作：索引可以减少磁盘IO操作，因为数据库可以直接通过索引定位到数据所在的磁盘位置，而不需要扫描整个表。
- 加速排序：如果查询需要对结果进行排序，索引可以提供有序的数据，从而加快排序操作的速度。

索引的缺点包括：

- 占用存储空间：索引需要占用额外的存储空间，特别是在大规模数据表中创建复合索引时，可能会占用较大的存储空间。
- 增加写操作的开销：当对表进行插入、更新或删除操作时，索引需要被更新，这会增加写操作的开销。
- 增加索引维护的成本：当表中的数据发生变化时，索引需要被维护，包括索引的创建、更新和删除操作，这会增加数据库的维护成本。

## 3. 脏读、不可重复读、幻读

### 1. 脏读 (Dirty Read)

脏读发生在一个事务读取了另一个事务修改但尚未提交的数据。如果修改的事务最后回滚，那么读取的数据就是无效的。

**示例**：

- 事务 A 修改一行数据。
- 事务 B 读取这行数据。
- 事务 A 决定回滚，撤销之前的修改。
- 事务 B 读取到的数据现在是无效的。

### 2. 不可重复读 (Non-repeatable Read)

不可重复读发生在一个事务内，当一个事务尝试多次读取同一数据时，由于其他事务的修改操作，导致这些读取操作返回的数据不一致。

**示例**：

- 事务 A 读取一行数据。
- 事务 B 修改这行数据。
- 事务 A 再次读取这行数据，发现数据已经被改变。

### 3. 幻读 (Phantom Read)

幻读是指在一个事务内读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，导致第一个事务在再次读取该范围的记录时，看到了之前未看到的“幻影”记录。

**示例**：

- 事务 A 读取满足某个条件的所有行，得到 N 行结果。
- 事务 B 插入了一些新的行，这些新行也满足事务 A 的查询条件。
- 事务 A 再次读取满足同一条件的所有行，但这次得到了 N+M 行结果。

### 区别

- **脏读**：与读取未提交的修改有关。这可能导致读取到最后被回滚的数据。
- **不可重复读**：与单个记录的修改有关。在同一个事务内，相同的查询返回了不同的结果。
- **幻读**：与记录的数量有关。在同一个事务内，相同的查询返回了不同数量的记录。

为了解决这些问题，数据库系统提供了不同级别的事务隔离，如读未提交、读已提交、可重复读和串行化。不同的隔离级别提供了不同的并发控制，以平衡性能和数据一致性之间的权衡。例如，InnoDB 存储引擎的默认隔离级别是“可重复读”，它可以防止不可重复读和幻读，但允许脏读。

## 4. 隔离级别

1. **Read Uncommitted (读未提交)**
   - 最低的隔离级别。
   - 一个事务可以读取另一个未提交事务的更改。
   - 可能会导致以下并发问题：
     - 脏读 (Dirty Reads): 读取到另一个事务未提交的数据。
     - 不可重复读 (Non-Repeatable Reads): 在同一个事务中，多次读取同一数据返回的结果不同。
     - 幻读 (Phantom Reads): 在一个事务中执行相同的查询两次，但由于另一个并发事务的插入操作，返回的结果集不同。
2. **Read Committed (读已提交)**  **Oracle默认隔离级别**
   - 默认的隔离级别（在许多数据库系统中）。
   - 一个事务只能读取已经提交的事务的更改。
   - 可能会导致以下并发问题：
     - 不可重复读 (Non-Repeatable Reads)
     - 幻读 (Phantom Reads)
3. **Repeatable Read (可重复读)**  **MySQL默认隔离级别**
   - 一个事务在其整个过程中都可以多次读取同一数据，并且每次读取的结果都是相同的。
   - 可能会导致以下并发问题：
     - 幻读 (Phantom Reads)
4. **Serializable (串行化)**
   - 最高的隔离级别。
   - 事务被处理得就像是串行执行的，即一个接一个地执行，没有并发。
   - 避免了所有上述的并发问题，但可能会导致性能下降，因为事务没有并发执行。

实现：

1. **Read Uncommitted (读未提交)**
   - 这个级别几乎不使用任何锁。事务可以读取其他事务修改但尚未提交的数据。
   - 通常，只有写操作（如INSERT、UPDATE、DELETE）会获取锁，以防止多个事务同时修改同一行。
2. **Read Committed (读已提交)**
   - 在这个级别，当一个事务想要读取一行数据时，它不会锁定那一行。但是，当一个事务想要修改一行数据时，它会锁定那一行，直到事务完成。
   - 这确保了一个事务不会读取其他事务尚未提交的数据。
   - 一些数据库系统使用行级锁来实现这个隔离级别，而其他系统可能使用版本控制。
3. **Repeatable Read (可重复读)**
   - 在这个级别，当一个事务读取一行数据时，它会锁定那一行，防止其他事务修改它。
   - 这确保了在同一个事务中，多次读取同一数据时，数据是一致的。
   - 但是，这个级别不会防止其他事务插入新的行，这就可能导致幻读。
   - 一些数据库系统使用行级锁和范围锁来实现这个隔离级别。
4. **Serializable (串行化)**
   - 这是最严格的隔离级别。在这个级别，事务被处理得就像是串行执行的。
   - 当一个事务读取一系列的行时，它会锁定整个范围，防止其他事务修改这些行或在这个范围内插入新的行。
   - 这个级别通常使用范围锁来实现。

## 5. 锁的类型

1. 意向锁：

 意向锁是一种表示事务打算给数据对象加上哪种类型的锁的锁，而不是实际上锁定数据对象本身。它们主要用于处理数据库系统中的锁冲突，确保系统在更精细的锁定级别（如行锁或页锁）上正确地应用锁。 

好处：

1. **减少锁检查的开销**： 意向锁允许数据库系统在高级（如表级）上快速检查锁的兼容性，而无需检查每个具体的行锁或页锁。这大大减少了锁检查的开销。
2. **提高并发性**： 通过使用意向锁，多个事务可以在同一表的不同行上并发地工作，而不会相互阻塞，从而提高了整体的并发性能。
3. **防止死锁**： 意向锁可以帮助数据库系统更早地检测到潜在的死锁情况，从而采取适当的措施来避免死锁。
4. **支持多级锁定策略**： 意向锁支持数据库系统的多级锁定策略，允许事务在不同的锁定级别（如表、页或行）上工作。



2. 乐观锁与悲观锁：
   1. 悲观锁（Pessimistic Locking）：

**哲学**：悲观锁的策略基于这样的假设：事务在处理数据时很可能会发生冲突，因此最好预先锁定数据，以防止其他事务访问它。

**实现**：

- 当事务想要读取或修改数据时，它首先锁定这些数据。
- 其他事务在此期间不能修改这些被锁定的数据，但根据锁的类型，它们可能可以读取数据。
- 当事务完成后，它会释放锁，使其他事务可以访问数据。

**优点**：

- 简单直接。
- 在高冲突的环境中，可以避免多次尝试和回滚。

**缺点**：

- 可能导致资源的低效利用，因为数据被锁定，其他事务必须等待。

- 可能导致死锁。

  2. 乐观锁（Optimistic Locking）：

**哲学**：乐观锁的策略基于这样的假设：冲突是罕见的，因此不需要预先锁定数据。相反，事务在提交时检查是否有其他事务已经修改了它们想要修改的数据。

**实现**：

- 事务读取数据但不锁定它。
- 在事务准备提交时，它会检查自从它读取数据以来是否有其他事务修改了这些数据。
  - 这通常是通过版本号、时间戳或校验和来实现的。
- 如果没有其他事务修改数据，那么事务可以成功提交。
- 如果数据已被其他事务修改，那么事务必须重新尝试或回滚。

**优点**：

- 在低冲突的环境中，可以提供更高的并发性能。
- 不容易导致死锁。

**缺点**：

- 在高冲突的环境中，可能需要多次尝试才能成功提交事务。
- 实现可能比悲观锁复杂。