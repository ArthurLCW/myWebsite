# 前端编程

## 1. [事件捕获与冒泡](https://www.bilibili.com/video/BV1m7411L7YW/?spm_id_from=333.788&vd_source=a82ddca015c3600e3ebfadd0eb69d716)

#### 1. DOM事件流

事件捕获阶段（自上而下）+处于目标阶段+事件冒泡阶段（自下而上）

#### 2. 例子

![1693208037428](javascript2.png)

事件捕获优先于事件冒泡。事件捕获从上到下，所以先触发mother再触发daughter。然后再事件冒泡自下而上，先baby再grandma。



## 2. 防抖（debounce）

**原理**：如果在一个时间段内连续触发同一个事件，只执行最后一次。

**常见应用场景**：搜索框实时搜索、窗口大小调整。

**示例**：

想象一个搜索框，用户在输入时，你希望能够实时显示搜索结果。但如果每次用户输入一个字符时都发送一个请求到服务器，服务器可能会被大量的请求淹没。使用防抖，只有当用户停止输入一段时间（例如300毫秒）后，才会发送一个请求。

```javascript
function debounce(func, delay) {
    let timeout;
    return function() {
        const context = this;
        const args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(function() {
            func.apply(context, args);
        }, delay);
    };
}

const searchInput = document.getElementById('searchInput');

searchInput.addEventListener('input', debounce(function() {
    console.log('Sending request for:', searchInput.value);
}, 300));
```

**难点0：流程**

clearTimeout，再setTimeout。例子：设置一个按钮，点击后会100ms后触发事件。第一次点击，设置100ms后触发。99ms后第二次点击，重新计时，事件再过100ms后触发

**难点1：回调函数的正确传入方式**

不可以直接searchInput.addEventListener('input', debounce(func)).直接这样写会在绑定时就执行debounce(func)。正确处理办法是debounce(func) return一个匿名或者箭头函数。

**难点2：闭包**

不用闭包的话每次会生成一个新的timeout，不能实现防抖效果。

**难点3：重新绑定**

非构造非方法非匿名非箭头的函数的this值默认为global/window，这可能导致一些问题。用apply显示的修改this值。

## 3.节流 (Throttle)

**原理**：在一个时间段内，不管事件触发多少次，只执行一次。

**常见应用场景**：滚动事件监听、持续的鼠标移动。

**示例**：

假设你有一个网页，当用户滚动到页面底部时，你希望加载更多的内容。用户在滚动页面时，滚动事件会非常频繁地触发。使用节流，即使用户连续滚动，你也只每隔一段时间（例如200毫秒）检查一次。

```javascript
function throttle(func, delay) {
    let lastTime = 0;
    return function() {
        const now = Date.now();
        if (now - lastTime > delay) {
            lastTime = now;
            func.apply(this, arguments);
        }
    };
}

window.addEventListener('scroll', throttle(function() {
    if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
        console.log('Load more content');
    }
}, 200));
```

## 4. 浏览器缓存

#### 1. 强缓存

- **Expires**：这是HTTP/1.0的属性，它指定了一个绝对的过期时间。例如：`Expires: Wed, 21 Oct 2020 07:28:00 GMT`。
- **Cache-Control**：这是HTTP/1.1的属性，它提供了更多的缓存控制选项。例如：
  - `max-age=3600`：资源会在3600秒后过期。
  - `public`：资源可以被所有用户缓存，包括在中间代理服务器中。
  - `private`：资源只能被浏览器缓存。
  - `no-cache`：需要向服务器验证资源的有效性。
  - `no-store`：不缓存资源。

#### 2. 协商缓存

当强缓存失效或不适用时，浏览器会尝试使用协商缓存。这涉及到与服务器的通信，以确定资源是否已更改。

- **Last-Modified / If-Modified-Since**：服务器通过`Last-Modified`标头提供资源的最后修改日期。在后续的请求中，浏览器使用`If-Modified-Since`标头提供此日期，如果资源未更改，服务器会返回`304 Not Modified`状态码。
- **ETag / If-None-Match**：`ETag`是资源的特定版本的标识符（如哈希）。如果资源更改，`ETag`也会更改。浏览器在后续的请求中使用`If-None-Match`标头提供此标识符，服务器会比较它，如果资源未更改，返回`304 Not Modified`状态码。

#### 3. **其他缓存机制**:

- **Service Workers**：这是一种在浏览器后台运行的脚本，它可以拦截和缓存网络请求，使得资源可以离线使用。
- **Memory Cache**：浏览器的内存中的短暂缓存，主要用于当前会话。当浏览器关闭或页面刷新时，内存缓存会被清空。
- **Disk Cache**：浏览器在硬盘上的缓存，用于长期存储。即使浏览器关闭或电脑重启，磁盘缓存也会保留。

#### 4. 优化策略：

1. **设置合适的缓存策略**：对于不经常更改的资源（如库、框架、图标等），使用长时间的强缓存。对于可能更改的资源，使用协商缓存。
2. **版本控制**：当资源更改时，更改其URL（例如，通过添加查询参数或更改文件名）以确保浏览器加载新版本。
3. **使用Service Workers**：为应用程序提供离线支持和更细粒度的缓存控制。
4. **优先考虑内存缓存**：对于频繁使用的资源，使其保持在内存缓存中可以提供最快的加载速度。

总的来说，正确地使用浏览器缓存可以显著提高网站的性能，减少服务器的负担，并为用户提供更快的加载速度。

## 5. 网页性能指标与优化

### 5.1. 性能指标

1. **加载时间（Load Time）**:
   - 这是最直观的性能指标之一，指的是页面完全加载所需的时间。这包括所有的HTML、CSS、JavaScript、图片和其他资源的加载时间。
2. **首次内容绘制（First Contentful Paint, FCP）**:
   - FCP指的是从页面开始加载到页面上的第一个内容元素（如文本或图像）被渲染的时间。
3. **首次有意义绘制（First Meaningful Paint, FMP）**:
   - FMP衡量的是页面主要内容开始出现在屏幕上的时间，这通常是用户认为页面“可用”的时刻。
4. **最大内容绘制（Largest Contentful Paint, LCP）**:
   - LCP衡量的是页面上最大内容元素（如大图像或文本块）完成渲染的时间。这是一个重要的用户体验指标。
5. **交互时间（Time to Interactive, TTI）**:
   - TTI是指页面完全可交互所需的时间，即用户可以完全与页面上的所有元素互动的时间点。
6. **阻塞时间（Blocking Time）**:
   - 这是指在FCP和TTI之间，主线程被阻塞的总时间，导致用户无法与页面互动。
7. **累积布局偏移（Cumulative Layout Shift, CLS）**:
   - CLS衡量的是视觉稳定性，即页面加载过程中元素位置变化的频率和程度。较低的CLS表示更好的用户体验。
8. **服务器响应时间（Time to First Byte, TTFB）**:
   - TTFB是指从用户或客户端发出请求到接收到来自服务器的第一个字节所需的时间。
9. **页面大小（Page Size）**:
   - 这是指页面的总体积，包括所有的代码、图片、视频等资源。页面大小越小，通常加载速度越快。
10. **请求数（Number of Requests）**:
    - 页面加载所需的总请求数。减少请求数通常有助于提高页面加载速度。

### 5.2. 性能优化

#### 1. Service Worker

Service Worker 是一个在浏览器背景中运行的 JavaScript 脚本，它独立于主线程，因此不会因为页面的计算或渲染任务而被阻塞。这使得 Service Worker 非常适合执行那些不需要用户交互并且希望在后台运行的任务，例如推送通知和背景同步。 

Service Worker 的主要特点：

1. **离线访问**：Service Worker 可以拦截网络请求，从缓存中提供资源，使 web 应用在离线时仍然可用。
2. **背景数据同步**：Service Worker 可以在后台同步数据，即使用户没有打开应用（**应用指网页，不是浏览器**）。
3. **推送通知**：即使 web 应用未打开，Service Worker 也可以接收来自服务器的推送通知，并在用户的设备上显示它们。
4. **网络请求代理**：Service Worker 可以拦截和缓存网络请求，从而提供更快的响应和更可靠的性能。

#### 2. CDN

CDN是内容分发网络（Content Delivery Network）的缩写。它是一种分布式网络，旨在通过地理上分散的服务器群来优化互联网内容的传输速度和可靠性。CDN通过在多个位置缓存内容（如网页、视频、图片等），使得用户可以从最近的服务器获取内容，而不是所有的请求都回到原始服务器。这样做有几个主要的好处：

1. **提高速度**：用户可以从离他们最近的数据中心下载内容，从而减少延迟，提高加载速度。
2. **减少原始服务器的负载**：由于许多请求被CDN上的服务器处理，原始服务器的负载会减少，这有助于避免过载情况的发生。
3. **增加可用性和可靠性**：如果某个服务器或数据中心出现问题，CDN可以将流量重定向到其他健康的服务器上，从而保证内容的持续可用性。
4. **提高安全性**：CDN可以提供额外的安全层，如DDoS攻击防护，因为它们可以分散流量，识别并阻止恶意流量。
5. **节省带宽成本**：通过缓存内容，CDN可以减少数据中心的数据传输量，从而节省成本。

总的来说，CDN是提升网站性能和用户体验的重要工具，尤其是对于有大量国际用户或需要快速内容交付的服务来说。



## 6. 浏览器进程（五大进程）

浏览器主进程、网络进程、GPU进程、渲染进程和插件进程。

每一个页面都有独立的渲染进程和插件进程，二者被放入沙箱中隔离保证安全性。

1. **浏览器进程（Browser Process）**：
   - 这是主控进程，负责浏览器的用户界面，包括地址栏、书签、前进和后退按钮等。
   - 它还负责管理窗口和标签页，以及与操作系统的交互。
2. **GPU进程（GPU Process）**：
   - 负责处理所有的GPU相关任务。
   - 它用于加速网页的渲染，特别是对于图形密集型的操作和视频播放。
3. **网络进程（Network Process）**：
   - 负责处理所有网络活动，如加载网页、下载文件等。
   - 它确保网络请求的处理不会影响到浏览器的用户界面或网页的渲染。
4. **渲染进程（Renderer Process）**：
   - 每个标签页通常都有自己的渲染进程。
   - 这个进程负责解析HTML、CSS和JavaScript，然后将它们转换为用户可以看到和与之交互的网页。
   - 由于每个标签页有自己的渲染进程，因此一个标签页崩溃不会影响其他标签页。
5. **插件进程（Plugin Process）**：
   - 每个插件一般都有自己的进程，以隔离潜在的崩溃和安全问题。



## 7.浏览器渲染

1. **解析HTML**: 浏览器首先获取HTML文件，并解析文件中的标记，构建一个称为DOM（文档对象模型）的结构。DOM是页面结构的内存表示。
2. **解析CSS**: 浏览器解析与HTML相关联的CSS文件，并根据选择器和规则生成CSSOM（CSS对象模型）。CSSOM与DOM结合，用于确定页面中每个元素的样式。
3. **构建渲染树**: 浏览器将DOM和CSSOM结合起来，创建一个渲染树。渲染树只包含需要显示的元素及其样式信息。
4. **布局（Reflow）**: 一旦渲染树构建完成，浏览器就会进行布局过程，也称为回流。在这个阶段，浏览器计算每个元素的确切位置和大小。
5. **绘制（Paint）**: 布局完成后，浏览器开始绘制页面，将每个元素转换成屏幕上的实际像素。
6. **合成（Compositing）**: 如果页面中有复杂的效果，如层叠、滤镜等，浏览器可能会将页面分成多个层并单独处理，最后将这些层合成最终的图像。

在整个过程中，浏览器可能会多次重复某些步骤，特别是当页面中的元素发生变化时（例如，由于JavaScript操作或动画）。这些重复的步骤可能包括布局、绘制和合成，这些过程通常被称为浏览器的重排和重绘。



js阻塞：

HTML5为我们提供了3种加载和执行网页JavaScript代码的方式。

| 属性  | 作用                                                         |
| ----- | ------------------------------------------------------------ |
| sync  | 主线程解析HTML过程中，如果遇到script脚本，就会停止页面的解析，并开启网络进程去加载脚本，脚本加载并执行完毕后，继续解析HTML。 |
| async | 主线程解析HTML过程中，碰到脚本，则开启网络进程去加载脚本，主线程继续解析HTML，脚本加载完成，就立即转去执行脚本。 |
| defer | 主线程解析HTML过程中，遇到设置了defer的脚本，则开启网络进程去加载脚本，主线程继续解析HTML，HTML解析和渲染完毕后，再执行脚本。 |

## 8. 同源策略与跨域问题

源/域=协议+域名+端口号

跨域（Cross-Origin）是指在互联网编程中，一个域下的文档或脚本尝试去请求另一个域下的资源时遇到的安全限制问题。这是一种由浏览器的同源策略（Same-Origin Policy）引起的安全机制。 

### 8.1. 同源策略的意义

同源策略的主要目的是为了保护用户的数据安全和隐私。没有这个策略，恶意网站可能会利用用户的浏览器来进行不安全的操作。

#### 例子：跨站脚本攻击（XSS）

假设 Alice 访问了一个银行网站 `bank.com` 并登录了她的账户。这个网站在她的浏览器中设置了一个包含认证信息的Cookie。如果同源策略不存在，Alice 访问另一个恶意网站 `evil.com` 时，`evil.com` 上的JavaScript脚本可以发送一个请求到 `bank.com` 并尝试获取她的个人信息或进行交易。

由于浏览器通常会自动发送与目标网站相关的Cookies，`evil.com` 的脚本可能会利用这些Cookies来模拟Alice对银行网站的请求。如果 `bank.com` 接收了这些请求，恶意网站就可能访问Alice的敏感信息或进行未经授权的操作。

### 8.2. 跨域问题的解决方案

#### 8.2.1. CORS（跨源资源共享）

CORS是最常用的解决跨域问题的标准方法。它允许服务器通过设置HTTP头部来明确允许某些跨源请求。

- **服务器端设置**: 在服务器响应头中添加`Access-Control-Allow-Origin`（可以设置为特定的域名或`*`表示任何域名）。
- **适用场景**: 适用于API服务器，特别是当你控制服务器时。

#### 8.2.2. JSONP（JSON with Padding）

JSONP是一种较老的技术，利用`  <script>  `标签没有跨域限制的特性来绕过同源策略。

- **实现方式**: 通过动态创建`  <script>  `标签并指定src为目标URL，服务器响应需要用JavaScript回调函数包裹JSON数据。
- **限制**: 只能用于GET请求。

#### 8.2.3. 代理服务器

在客户端和目标服务器之间设置一个代理服务器，由代理服务器转发请求和响应。

- **实现方式**: 在同源的服务器上设置一个代理服务，该服务将请求转发到目标服务器，并将响应返回给客户端。
- **适用场景**: 当你无法控制API服务器或需要隐藏目标服务器的细节时。



## 9. 像素

### 9.1. 不同设备上的像素

1. **物理像素**:
   - 物理像素是指显示屏上实际存在的像素。不同设备的屏幕尺寸和分辨率不同，因此物理像素的数量和大小也不同。
2. **逻辑像素（CSS像素）**:
   - 在网页设计和开发中，我们通常谈论的是逻辑像素，也称为CSS像素。这是一个抽象的单位，用于在不同设备上保持一致的尺寸和布局。由于设备的物理像素密度（PPI）不同，同样数量的逻辑像素在不同设备上可能占据不同的物理空间。
3. **设备像素比（Device Pixel Ratio, DPR）**:
   - 设备像素比是物理像素和逻辑像素之间的比率。例如，高分辨率屏幕（如Retina显示屏）可能有更高的设备像素比，意味着一个逻辑像素可能对应多个物理像素。

### 9.2. 像素密度和分辨率

- **像素密度**（PPI，每英寸像素数）是衡量显示设备清晰度的一个重要指标。像素密度越高，图像通常看起来越清晰。
- **分辨率**是指屏幕上物理像素的总数，通常以宽度和高度的像素数表示（例如1920x1080）。





## 10. 网站白屏的可能原因

 如果刚开始我的网页正常运行，后来用户访问的时候却出现了白屏。可能的原因有哪些 ？

1. **服务器问题**：
   - 服务器可能遇到了性能问题或崩溃，导致无法正确响应请求。
   - 服务器上的后端服务（如数据库）可能出现故障。
2. 前端代码bug
3. 后端代码bug
4. **资源加载问题**：
   - 外部资源（如脚本、样式表、图片等）可能因为路径更改、删除或服务器问题而无法加载。
   - CDN 服务可能出现问题，导致资源无法正确加载。
5. **第三方服务或API问题**：
   - 如果您的网站依赖于第三方服务或API，这些服务的不可用或更改可能导致页面无法加载。
6. **浏览器兼容性问题**：
   - 新代码可能在某些浏览器上不兼容，尤其是在老旧的浏览器版本上。。
7. **网络问题**：
   - 用户的网络连接可能出现问题，或者您的服务器网络环境发生变化。
8. url输入错误



## 11. canvas和svg

Canvas 和 SVG 都是用于在网页上创建图形的技术，但它们在实现和使用上有着本质的不同。

### Canvas

1. **基本概念**：Canvas 是 HTML5 提供的一个元素，用于通过 JavaScript 来绘制图像（像素级操作）。它可以用来绘制图形、制作动画、游戏图形等。
2. **如何工作**：Canvas 工作方式类似于画布，一旦图形被绘制，它就不会被保留（即绘制后这个图形就成了canvas的一部分，无法再删除/修改这个图形）。如果需要更新图形，整个场景需要重新绘制，包括任何之前绘制的图形。
3. **优点**：
   - 高性能：对于大型渲染，如游戏或者视频处理，Canvas 可以更高效。
   - 像素级控制：可以精确控制每个像素，适合复杂的图像处理。
4. **缺点**：
   - 不支持事件处理器：Canvas 内的图形元素不能附加事件处理器。
   - 不利于SEO：Canvas 绘制的内容不会被搜索引擎抓取。
   - 可访问性差：需要额外工作来实现屏幕阅读器的可访问性。

### SVG

1. **基本概念**：SVG（Scalable Vector Graphics）是一种使用 XML 描述 2D 图形的语言。SVG 图像在放大或缩小时不会失真。
2. **如何工作**：SVG 通过文本文件定义图形，这些文件可以被搜索、索引、脚本化或压缩。SVG 是 W3C 的一个标准，与 HTML5 完全兼容。
3. **优点**：
   - 可缩放性：向量图形可以无限放大或缩小，而不会失真。
   - 可编辑性：SVG 文件是 XML 格式，可以通过文本编辑器或绘图软件编辑。
   - 事件处理：SVG 元素可以绑定 JavaScript 事件处理器。
   - SEO 友好：SVG 图形可以被搜索引擎索引和抓取。
   - 更好的可访问性：支持文本标签和其他辅助功能。
4. **缺点**：
   - 性能问题：对于复杂的图形或大型渲染，SVG 可能不如 Canvas 高效。
   - 兼容性问题：老旧的浏览器可能不完全支持 SVG。



## 12. 如何制作动画

### 1. 方法一：利用canvas和requestAnimationFrame

首先，您需要在 HTML 中定义一个 `canvas` 元素：

```html
<canvas id="myCanvas" width="400" height="400"></canvas>
```

然后，在 JavaScript 中，您可以这样编写 `draw` 函数：

```javascript
// 获取 Canvas 元素及其绘图上下文
var canvas = document.getElementById('myCanvas');
var ctx = canvas.getContext('2d');

// 假设我们有一个动画的 x 和 y 坐标
var x = 0;
var y = 0;

function draw() {
    // 清除整个画布
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 绘制动画的内容
    // 例如，绘制一个简单的矩形
    ctx.fillStyle = 'blue';
    ctx.fillRect(x, y, 50, 50);

    // 更新下一帧的位置
    x += 1;
    y += 1;

    // 请求下一帧
    requestAnimationFrame(draw);
}

// 初始调用
draw();
```

在这个例子中，每次调用 `draw` 函数时，它首先使用 `ctx.clearRect` 清除整个 Canvas。然后，它使用 `ctx.fillRect` 在新位置绘制一个矩形。每帧我们稍微改变矩形的位置 (`x` 和 `y` 坐标)，这样就创建了一个移动的矩形的效果。最后，通过 `requestAnimationFrame(draw)` 请求下一帧，从而形成一个连续的动画循环。

这个简单的例子展示了如何使用 Canvas 和 `requestAnimationFrame` 来创建基本的动画效果。您可以通过更改 `draw` 函数中的逻辑来创建更复杂和有趣的动画。

### 2. 方法二：css

#### 1. CSS Transitions

CSS 过渡（Transitions）允许您在 CSS 属性值之间平滑过渡。这适用于在状态改变时（如伪类：`:hover`）产生的样式变化。

**基本语法**：

```css
.element {
    transition: property duration timing-function delay;
}
```

- `property`：要过渡的 CSS 属性（如 `opacity`, `background-color`）。
- `duration`：过渡持续时间。
- `timing-function`：过渡的速度曲线（如 `linear`, `ease-in`, `ease-out`）。
- `delay`：过渡开始前的延迟。

**示例**：当鼠标悬停在元素上时改变颜色。

```css
div {
    background-color: blue;
    transition: background-color 0.5s ease-in-out;
}

div:hover {
    background-color: red;
}
```

#### 2. CSS Animations

CSS 动画（Animations）允许您创建复杂的动画序列，通过定义**关键帧（keyframes）**来控制动画序列。

**基本语法**：

```css
@keyframes animation-name {
    from {
        /* 开始状态 */
    }
    to {
        /* 结束状态 */
    }
}

.element {
    animation: animation-name duration timing-function delay iteration-count direction fill-mode;
}
```

- `animation-name`：动画的名称，对应于 `@keyframes` 定义。
- `duration`：动画持续时间。
- `timing-function`：动画的速度曲线。
- `delay`：动画开始前的延迟。
- `iteration-count`：动画播放次数（`infinite` 为无限次）。
- `direction`：动画是否反向播放。
- `fill-mode`：动画完成后的状态。

**示例**：创建一个无限旋转的动画。

```css
@keyframes spin {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}

div {
    animation: spin 2s linear infinite;
}
```































